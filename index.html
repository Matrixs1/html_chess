<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 2px;
            margin: 20px auto;
            width: 500px;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            border: 1px solid #000;
        }
        .row:nth-child(even) .square:nth-child(odd),
        .row:nth-child(odd) .square:nth-child(even) {
            background-color: #769656;
        }
        .row:nth-child(even) .square:nth-child(even),
        .row:nth-child(odd) .square:nth-child(odd) {
            background-color: #eeeed2;
        }
        #game-over {
            font-size: 24px;
            margin-top: 20px;
            color: red;
        }
        #restart-button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        #color-selection {
            margin-top: 20px;
        }
        #color-selection button {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <h1>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬</h1>
    <div id="color-selection">
        <p>Ø§Ø®ØªØ± Ù„ÙˆÙ†Ùƒ:</p>
        <button id="white-button">Ø£Ø¨ÙŠØ¶</button>
        <button id="black-button">Ø£Ø³ÙˆØ¯</button>
    </div>
    

    <div id="chessboard"></div>
    <div id="turn-display">Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠ: Ø§Ù„Ø£Ø¨ÙŠØ¶</div>
    <div id="game-over"></div>
    <button id="restart-button" style="display: none;">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„</button>
    <script>
        class ChessGame {
          
            constructor(playerColor) {
                this.board = this.createBoard();
                this.turn = 'white';
                this.selectedPiece = null;
                this.gameOver = false;
                this.playerColor = playerColor;
                this.aiColor = playerColor === 'white' ? 'black' : 'white';
                this.previousMoves = [];
                this.initGame();
            }
      // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ù…Ù† Ù…Ù„Ù JSON
    async loadAIMoves() {
        try {
            const response = await fetch('moves.json'); // Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù JSON
            const data = await response.json();
            this.aiMoves = data.moves;
        } catch (error) {
            console.error('Error loading AI moves:', error);
        }
    }

    getAvailableMoves(color) {
    const moves = [];
    const pieces = this.getPiecesForColor(color);  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…Ø­Ø¯Ø¯

    for (const piece of pieces) {
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                if (this.isValidMove(piece.row, piece.col, i, j)) {
                    moves.push({ from: piece, to: { row: i, col: j } });
                }
            }
        }
    }
    return moves;
}
aiMove() {
    if (this.turn === this.aiColor && !this.gameOver) {
        const availableAIMoves = this.getAvailableMoves(this.aiColor);

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ ÙƒØ´
        if (this.isKingInCheck()) {
            console.log("âš  Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ ÙƒØ´! ÙŠØ¬Ø¨ ØªØ­Ø±ÙŠÙƒÙ‡ Ø£Ùˆ Ø­Ù…Ø§ÙŠØªÙ‡.");

            // Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„Ù…Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ø±Ùƒ Ù„Ø­Ø±ÙƒØ© Ø¢Ù…Ù†Ø©
            const kingEscapeMove = this.findKingEscapeMove(availableAIMoves);
            if (kingEscapeMove) {
                console.log("ğŸ”¹ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ù„Ùƒ Ù„Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„ÙƒØ´.");
                this.executeMove(kingEscapeMove);
                return;
            }

            // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙƒØ© Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ùƒ (ÙˆØ¶Ø¹ Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰ ÙÙŠ Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù‡Ø¬ÙˆÙ…)
            const blockingMove = this.findBlockingMove(availableAIMoves);
            if (blockingMove) {
                console.log("ğŸ›¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ùƒ Ø¨Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰.");
                this.executeMove(blockingMove);
                return;
            }

            // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ Ø­Ø±ÙƒØ© Ù…Ù…ÙƒÙ†Ø© Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ù„ÙƒØŒ ÙŠØªÙ… Ø¥Ø¹Ù„Ø§Ù† Ø§Ù„Ù‡Ø²ÙŠÙ…Ø© (ÙƒØ´ Ù…Ø§Øª)
            console.log("ğŸ’€ ÙƒØ´ Ù…Ø§Øª! Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ÙØ±.");
            this.gameOver = true;
            return;
        }

        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ ÙƒØ´ØŒ ÙŠØªØ­Ø±Ùƒ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ
        const killingMove = this.findKillingMove(availableAIMoves);
        if (killingMove) {
            console.log("âš” ØªÙ†ÙÙŠØ° Ù‡Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø© Ø§Ù„Ø®ØµÙ….");
            this.executeMove(killingMove);
            return;
        }

        if (availableAIMoves.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableAIMoves.length);
            console.log("ğŸ² ØªÙ†ÙÙŠØ° Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©.");
            this.executeMove(availableAIMoves[randomIndex]);
        }
    }
}


executeMove(move) {
    this.board[move.to.row][move.to.col] = this.board[move.from.row][move.from.col];
    this.board[move.from.row][move.from.col] = null;

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯ÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨
    this.turn = this.playerColor;

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„ÙˆØ­Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø¯ÙˆØ±
    this.renderBoard();
    this.updateTurnDisplay();

    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ ÙƒØ´ Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø±ÙƒØ©
    if (this.isKingInCheck()) {
        console.log("âš  Ø¨Ø¹Ø¯ ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ©ØŒ Ø§Ù„Ù…Ù„Ùƒ Ù„Ø§ ÙŠØ²Ø§Ù„ ÙÙŠ ÙƒØ´! Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø³Ø§Ø¨.");
        this.aiMove(); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ø§Ø®ØªÙŠØ§Ø± ØªØµØ­ÙŠØ­ Ø£ÙØ¶Ù„
        return;
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚
    this.checkGameOver();
    this.checkPawnPromotion(move.to.row, move.to.col);
}


// Ø¯Ø§Ù„Ø© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙƒØ© ØªÙ†Ù‚Ø° Ø§Ù„Ù…Ù„Ùƒ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙÙŠ Ø®Ø·Ø±
findKingEscapeMove(moves) {
    const kingSymbol = this.aiColor === 'white' ? 'â™”' : 'â™š';
    let kingPosition = null;

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù„Ùƒ
    for (let row = 0; row < this.board.length; row++) {
        for (let col = 0; col < this.board[row].length; col++) {
            if (this.board[row][col] === kingSymbol) {
                kingPosition = { row, col };
                break;
            }
        }
        if (kingPosition) break;
    }

    if (!kingPosition) return null; // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ù…Ù„Ùƒ Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ØŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‡Ø±ÙˆØ¨

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙƒØ© Ø¢Ù…Ù†Ø© Ù„Ù„Ù…Ù„Ùƒ ÙÙ‚Ø·
    for (const move of moves) {
        if (move.piece === kingSymbol) {
            // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù…Ø¹Ø±ÙØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø³ØªØ®Ø±Ø¬ Ø§Ù„Ù…Ù„Ùƒ Ù…Ù† Ø§Ù„ÙƒØ´
            const originalPiece = this.board[move.to.row][move.to.col];
            this.board[move.to.row][move.to.col] = kingSymbol;
            this.board[move.from.row][move.from.col] = null;

            const stillInCheck = this.isPositionUnderAttack({ row: move.to.row, col: move.to.col });

            // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ÙØ­Øµ
            this.board[move.from.row][move.from.col] = kingSymbol;
            this.board[move.to.row][move.to.col] = originalPiece;

            if (!stillInCheck) {
                return move; // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯ ØºÙŠØ± Ù…Ù‡Ø¯Ø¯ØŒ Ù†ØªØ­Ø±Ùƒ Ø¥Ù„ÙŠÙ‡
            }
        }
    }

    return null; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø®Ø±Ø¬ Ù„Ù„Ù…Ù„Ùƒ
}

// Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ ÙˆØ¶Ø¹ ÙƒØ´
isKingInCheck() {
    const kingSymbol = this.aiColor === 'white' ? 'â™”' : 'â™š';
    let kingPosition = null;

    // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù„Ùƒ
    for (let row = 0; row < this.board.length; row++) {
        for (let col = 0; col < this.board[row].length; col++) {
            if (this.board[row][col] === kingSymbol) {
                kingPosition = { row, col };
                break;
            }
        }
        if (kingPosition) break;
    }

    if (!kingPosition) return false;

    return this.isPositionUnderAttack(kingPosition);
}

// Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ÙƒØ§Ù† Ù…Ù‡Ø¯Ø¯Ù‹Ø§ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø®ØµÙ…
isPositionUnderAttack(position) {
    const opponentColor = this.aiColor === 'white' ? 'black' : 'white';
    const opponentMoves = this.getAvailableMoves(opponentColor);

    for (const move of opponentMoves) {
        if (move.to.row === position.row && move.to.col === position.col) {
            return true; // Ø§Ù„Ù…ÙƒØ§Ù† Ù…Ù‡Ø¯Ø¯
        }
    }
    return false; // Ø§Ù„Ù…ÙƒØ§Ù† Ø¢Ù…Ù†
}

// Ø¥ÙŠØ¬Ø§Ø¯ Ø­Ø±ÙƒØ© Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ù„Ùƒ Ù…Ø«Ù„ Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ù‡Ø¬ÙˆÙ…
findBlockingMove(moves) {
    const kingSymbol = this.aiColor === 'white' ? 'â™”' : 'â™š';
    let kingPosition = null;

    // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù„Ùƒ
    for (let row = 0; row < this.board.length; row++) {
        for (let col = 0; col < this.board[row].length; col++) {
            if (this.board[row][col] === kingSymbol) {
                kingPosition = { row, col };
                break;
            }
        }
        if (kingPosition) break;
    }

    if (!kingPosition) return null;

    for (const move of moves) {
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© ØªØ­Ù…ÙŠ Ø§Ù„Ù…Ù„Ùƒ (Ù…Ø«Ù„Ø§Ù‹ Ø¨Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰)
        if (this.isBlockingAttack(move, kingPosition)) {
            return move;
        }
    }

    return null;
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© ØªØ³Ø¯ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ùƒ
isBlockingAttack(move, kingPosition) {
    // ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ø´ÙƒÙ„ Ù…Ø¤Ù‚Øª Ù„Ù…Ø¹Ø±ÙØ© ØªØ£Ø«ÙŠØ±Ù‡Ø§
    const originalPiece = this.board[move.to.row][move.to.col];
    this.board[move.to.row][move.to.col] = move.piece;
    this.board[move.from.row][move.from.col] = null;

    const stillInCheck = this.isPositionUnderAttack(kingPosition);

    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ØµÙ„ÙŠ
    this.board[move.from.row][move.from.col] = move.piece;
    this.board[move.to.row][move.to.col] = originalPiece;

    return !stillInCheck;
}



// Ø¯Ø§Ù„Ø© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙƒØ© ØªÙ‚ØªÙ„ Ø§Ù„Ù…Ù„Ùƒ Ø£ÙˆÙ„Ø§Ù‹ØŒ ÙˆØ¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ ÙŠØ¨Ø­Ø« Ø¹Ù† Ø£ÙŠ Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰
findKillingMove(moves) {
    let bestMove = null;

    for (const move of moves) {
        const targetPiece = this.board[move.to.row][move.to.col];

        if (targetPiece) {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© ØªÙ‚ØªÙ„ Ø§Ù„Ù…Ù„Ùƒ
            if ((this.aiColor === 'white' && targetPiece === 'â™š') || (this.aiColor === 'black' && targetPiece === 'â™”')) {
                return move; // Ø¥Ø°Ø§ ÙˆØ¬Ø¯Ù†Ø§ Ø­Ø±ÙƒØ© ØªÙ‚ØªÙ„ Ø§Ù„Ù…Ù„ÙƒØŒ Ù†Ù†ÙØ°Ù‡Ø§ ÙÙˆØ±Ù‹Ø§
            }

            // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ø­Ø±ÙƒØ© ØªÙ‚ØªÙ„ Ø§Ù„Ù…Ù„ÙƒØŒ Ù†Ø­ÙØ¸Ù‡Ø§ ÙƒØ®ÙŠØ§Ø± Ø§Ø­ØªÙŠØ§Ø·ÙŠ
            if (!bestMove && (this.aiColor === 'white' ? "â™Ÿâ™œâ™â™â™›".includes(targetPiece) : "â™™â™–â™˜â™—â™•".includes(targetPiece))) {
                bestMove = move;
            }
        }
    }

    return bestMove; // Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© Ù…ØªØ§Ø­Ø© (Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ Ø­Ø±ÙƒØ© ØªÙ‚ØªÙ„ Ø§Ù„Ù…Ù„Ùƒ)
}

// Ø¯Ø§Ù„Ø© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙƒØ© ØªÙ†Ù‚Ø° Ø¬Ù†Ø¯ÙŠÙ‹Ø§ Ù…Ù† Ø§Ù„Ù…ÙˆØª
findSavingMove(moves) {
    for (const move of moves) {
        const targetPiece = this.board[move.to.row][move.to.col];
        if (targetPiece && (this.aiColor === 'white' ? "â™™".includes(targetPiece) : "â™Ÿ".includes(targetPiece))) {
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø­Ø±ÙƒØ© ØªÙ†Ù‚Ø° Ø¬Ù†Ø¯ÙŠÙ‹Ø§ØŒ Ù†Ø¹ÙŠØ¯Ù‡Ø§
            return move;
        }
    }
    return null; // Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ© ØªÙ†Ù‚Ø° Ø¬Ù†Ø¯ÙŠÙ‹Ø§
}

// Ø¯Ø§Ù„Ø© Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ©
executeMove(move) {
    this.board[move.to.row][move.to.col] = this.board[move.from.row][move.from.col];
    this.board[move.from.row][move.from.col] = null;

    // ØªØºÙŠÙŠØ± Ø§Ù„Ø¯ÙˆØ± Ø¥Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨
    this.turn = this.playerColor;

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„ÙˆØ­Ø© ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø¯ÙˆØ±
    this.renderBoard();
    this.updateTurnDisplay();

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚
    this.checkGameOver();
    this.checkPawnPromotion(move.to.row, move.to.col);
}
        

getPreviousMovesForColor(color) {
    return this.previousMoves.filter(move => {
        const from = this.notationToIndices(move.from);
        const piece = this.board[from.row][from.col];
        return (color === 'white' ? "â™™â™–â™˜â™—â™•â™”".includes(piece) : "â™Ÿâ™œâ™â™â™›â™š".includes(piece));
    });
}

notationToIndices(notation) {
    const col = notation.charCodeAt(0) - 'a'.charCodeAt(0);
    const row = 8 - parseInt(notation[1]);
    return { row, col };
}

indicesToNotation(row, col) {
    const colChar = String.fromCharCode(col + 'a'.charCodeAt(0));
    const rowNum = 8 - row;
    return colChar + rowNum;
}


    // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ù‚Ø·Ø¹ Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…Ø­Ø¯Ø¯
    getPiecesForColor(color) {
        const pieces = [];
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                const piece = this.board[i][j];
                if (piece && (color === 'white' ? "â™™â™–â™˜â™—â™•â™”".includes(piece) : "â™Ÿâ™œâ™â™â™›â™š".includes(piece))) {
                    pieces.push({ row: i, col: j });
                }
            }
        }
        return pieces;
    }

   // Ø¯Ø§Ù„Ø© Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
   initGame() {
        this.renderBoard();
        this.updateTurnDisplay();
        document.getElementById('restart-button').addEventListener('click', () => this.restartGame());

        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙŠÙ„Ø¹Ø¨ Ø¨Ø§Ù„Ø£Ø³ÙˆØ¯ØŒ Ù†Ø¨Ø¯Ø£ Ø¨Ø­Ø±ÙƒØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
        if (this.playerColor === 'black') {
            setTimeout(() => this.aiMove(), 500);
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù„ÙˆØ­Ø©
    renderBoard() {
        let boardHTML = '<div id="board" style="display: grid; grid-template-columns: repeat(8, 60px); width: 500px;">';
        
        let startRow = this.playerColor === 'black' ? 7 : 0;
        let endRow = this.playerColor === 'black' ? -1 : 8;
        let step = this.playerColor === 'black' ? -1 : 1;

        for (let i = startRow; i !== endRow; i += step) {
            for (let j = 0; j < 8; j++) {
                let piece = this.board[i][j] ? this.board[i][j] : '';
                let color = (i + j) % 2 === 0 ? '#eeeed2' : '#769656';
                boardHTML += `<div class="square" data-row="${i}" data-col="${j}" draggable="true" 
                    style="width: 60px; height: 60px; background: ${color}; display: flex; align-items: center; 
                    justify-content: center; font-size: 24px;">${piece}</div>`;
            }
        }

        boardHTML += '</div>';
        document.getElementById('chessboard').innerHTML = boardHTML;
        this.addDragAndDrop();
    }
           
        
            addDragAndDrop() {
                    document.querySelectorAll('.square').forEach(square => {
                        square.addEventListener('dragstart', (e) => {
                            if (this.gameOver) {
                                e.preventDefault();
                                return;
                            }
                            let fromRow = parseInt(e.target.dataset.row);
                            let fromCol = parseInt(e.target.dataset.col);
                            let piece = this.board[fromRow][fromCol];

                            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¯ÙˆØ± Ù‡Ùˆ Ø§Ù„ØµØ­ÙŠØ­
                            if ((this.turn === 'white' && !"â™™â™–â™˜â™—â™•â™”".includes(piece)) ||
                                (this.turn === 'black' && !"â™Ÿâ™œâ™â™â™›â™š".includes(piece))) {
                                e.preventDefault();
                                return;
                            }

                            this.selectedPiece = e.target;
                        });

                        square.addEventListener('dragover', (e) => {
                            e.preventDefault();
                        });

                        square.addEventListener('drop', (e) => {
                            e.preventDefault();
                            if (this.selectedPiece && this.selectedPiece !== e.target && !this.gameOver) {
                                let fromRow = parseInt(this.selectedPiece.dataset.row);
                                let fromCol = parseInt(this.selectedPiece.dataset.col);
                                let toRow = parseInt(e.target.dataset.row);
                                let toCol = parseInt(e.target.dataset.col);

                                if (this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    this.board[toRow][toCol] = this.board[fromRow][fromCol];
                                    this.board[fromRow][fromCol] = null;
                                    this.turn = this.turn === 'white' ? 'black' : 'white';
                                    this.previousMoves.push({ from: this.indicesToNotation(fromRow, fromCol), to: this.indicesToNotation(toRow, toCol) });
                                    this.renderBoard();
                                    this.updateTurnDisplay();
                                    this.checkGameOver();
                                    this.checkPawnPromotion(toRow, toCol);

                                    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ø¹Ø¯ ØªØ­Ø±Ùƒ Ø§Ù„Ù„Ø§Ø¹Ø¨
                                    setTimeout(() => this.aiMove(), 500);
                                }
                            }
                        });
                    });
                }
                createBoard() {
                let board = [
                    ['â™œ', 'â™', 'â™', 'â™›', 'â™š', 'â™', 'â™', 'â™œ'],
                    ['â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ', 'â™Ÿ'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™', 'â™™'],
                    ['â™–', 'â™˜', 'â™—', 'â™•', 'â™”', 'â™—', 'â™˜', 'â™–']
                ];

                // Ø¹ÙƒØ³ Ø§Ù„Ù„ÙˆØ­Ø© Ø¥Ø°Ø§ Ø§Ø®ØªØ§Ø± Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ø³ÙˆØ¯
                if (this.playerColor === 'black') {
                    board.reverse();
                }

                return board;
            }


            isValidMove(fromRow, fromCol, toRow, toCol) {
    const piece = this.board[fromRow][fromCol];
    const targetPiece = this.board[toRow][toCol];

    // Ø§Ù„Ø­Ø±ÙƒØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© ØªØªØ­Ø±Ùƒ Ø¥Ù„Ù‰ Ù†ÙØ³ Ø§Ù„Ù…ÙˆÙ‚Ø¹
    if (fromRow === toRow && fromCol === toCol) {
        return false;
    }

    // Ø§Ù„Ø­Ø±ÙƒØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø·Ø¹Ø© ØªØªØ­Ø±Ùƒ Ø¥Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø© Ù…Ù† Ù†ÙØ³ Ø§Ù„Ù„ÙˆÙ†
    if (targetPiece && (this.turn === 'white' ? "â™™â™–â™˜â™—â™•â™”".includes(targetPiece) : "â™Ÿâ™œâ™â™â™›â™š".includes(targetPiece))) {
        return false;
    }

    // Ù‚ÙˆØ§Ø¹Ø¯ Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ø·Ø¹
    switch (piece) {
        // Ø­Ø±ÙƒØ© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ (Ø§Ù„Ø¬Ù†ÙˆØ¯)
        case 'â™™':
            if (fromCol === toCol && fromRow - 1 === toRow && !targetPiece) return true;
            if (fromCol === toCol && fromRow === 6 && toRow === 4 && !this.board[5][toCol] && !targetPiece) return true;
            if (Math.abs(fromCol - toCol) === 1 && fromRow - 1 === toRow && targetPiece) return true;
            break;
        case 'â™Ÿ':
            if (fromCol === toCol && fromRow + 1 === toRow && !targetPiece) return true;
            if (fromCol === toCol && fromRow === 1 && toRow === 3 && !this.board[2][toCol] && !targetPiece) return true;
            if (Math.abs(fromCol - toCol) === 1 && fromRow + 1 === toRow && targetPiece) return true;
            break;

        // Ø­Ø±ÙƒØ© Ø§Ù„Ù‚Ù„Ø¹Ø© (Ø§Ù„Ø±Ø®)
        case 'â™–':
        case 'â™œ':
            if (fromRow === toRow || fromCol === toCol) {
                if (this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
            }
            break;

        // Ø­Ø±ÙƒØ© Ø§Ù„Ø­ØµØ§Ù†
        case 'â™˜':
        case 'â™':
            if ((Math.abs(fromRow - toRow) === 2 && Math.abs(fromCol - toCol) === 1) ||
                (Math.abs(fromRow - toRow) === 1 && Math.abs(fromCol - toCol) === 2)) {
                return true;
            }
            break;

        // Ø­Ø±ÙƒØ© Ø§Ù„ÙÙŠÙ„
        case 'â™—':
        case 'â™':
            if (Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                if (this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
            }
            break;

        // Ø­Ø±ÙƒØ© Ø§Ù„ÙˆØ²ÙŠØ± (Ø§Ù„Ù…Ù„ÙƒØ©)
        case 'â™•':
        case 'â™›':
            if (fromRow === toRow || fromCol === toCol || Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol)) {
                if (this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
            }
            break;

        // Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ù„Ùƒ
        case 'â™”':
        case 'â™š':
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªÙ‡Ø¯ÙŠØ¯ Ø¨Ø§Ù„ÙÙŠÙ„ Ø£Ùˆ Ø§Ù„ÙˆØ²ÙŠØ±
            if (this.isKingUnderThreat(fromRow, fromCol)) {
                // Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„Ù…Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø±ÙƒØ© Ø´Ù…Ø§Ù„Ù‹Ø§ Ø£Ùˆ ÙŠÙ…ÙŠÙ†Ù‹Ø§ ÙÙ‚Ø·
                if (fromRow === toRow && Math.abs(fromCol - toCol) === 1 && !targetPiece) {
                    return true;
                }
                return false; // Ù„Ø§ ØªØ³Ù…Ø­ Ø¨Ø£ÙŠ Ø­Ø±ÙƒØ© Ø£Ø®Ø±Ù‰
            }

            // Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© Ù„Ù„Ù…Ù„Ùƒ
            if (Math.abs(fromRow - toRow) <= 1 && Math.abs(fromCol - toCol) <= 1) {
                return true;
            }
            break;
    }

    return false; // Ø§Ù„Ø­Ø±ÙƒØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙ…Ø± Ø¨Ø£ÙŠ Ù…Ù† Ø§Ù„Ø´Ø±ÙˆØ· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
}

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªÙ‡Ø¯ÙŠØ¯ Ù„Ù„Ù…Ù„Ùƒ
isKingUnderThreat(kingRow, kingCol) {
    const enemyPieces = this.turn === 'white' ? ["â™Ÿ", "â™œ", "â™", "â™", "â™›", "â™š"] : ["â™™", "â™–", "â™˜", "â™—", "â™•", "â™”"];

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªÙ‡Ø¯ÙŠØ¯ Ø¨Ø§Ù„ÙÙŠÙ„ Ø£Ùˆ Ø§Ù„ÙˆØ²ÙŠØ±
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = this.board[row][col];
            if (enemyPieces.includes(piece)) {
                if (this.isValidMove(row, col, kingRow, kingCol)) {
                    return true; // Ø§Ù„Ù…Ù„Ùƒ Ù…Ù‡Ø¯Ø¯
                }
            }
        }
    }

    return false; // Ø§Ù„Ù…Ù„Ùƒ Ù„ÙŠØ³ Ù…Ù‡Ø¯Ø¯Ù‹Ø§
}

            isPathClear(fromRow, fromCol, toRow, toCol) {
                let rowStep = fromRow < toRow ? 1 : -1;
                let colStep = fromCol < toCol ? 1 : -1;

                if (fromRow === toRow) {
                    for (let col = fromCol + colStep; col !== toCol; col += colStep) {
                        if (this.board[fromRow][col]) return false;
                    }
                } else if (fromCol === toCol) {
                    for (let row = fromRow + rowStep; row !== toRow; row += rowStep) {
                        if (this.board[row][fromCol]) return false;
                    }
                } else {
                    for (let row = fromRow + rowStep, col = fromCol + colStep; row !== toRow; row += rowStep, col += colStep) {
                        if (this.board[row][col]) return false;
                    }
                }

                return true;
            }
            
            // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠ
            updateTurnDisplay() {
                document.getElementById('turn-display').innerText = `Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠ: ${this.turn === 'white' ? 'Ø§Ù„Ø£Ø¨ÙŠØ¶' : 'Ø§Ù„Ø£Ø³ÙˆØ¯'}`;
            }
            checkGameOver() {
                const king = this.turn === 'white' ? 'â™”' : 'â™š';
                let kingPosition = null;

                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ù„Ùƒ
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        if (this.board[i][j] === king) {
                            kingPosition = { row: i, col: j };
                            break;
                        }
                    }
                    if (kingPosition) break;
                }

                if (!kingPosition) {
                    this.gameOver = true;

                    const whiteButton = document.getElementById('white-button');
                    if (whiteButton) {
                        whiteButton.click();
                    } else {
                        console.error("Ø§Ù„Ø¹Ù†ØµØ± 'white-button' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.");
                    }

                    document.getElementById('game-over').innerText = `ÙƒØ´ Ù…Ø§Øª! Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ${this.turn === 'white' ? 'Ø§Ù„Ø£Ø³ÙˆØ¯' : 'Ø§Ù„Ø£Ø¨ÙŠØ¶'}`;
                    document.getElementById('restart-button').style.display = 'block';
                    return;
                }

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ Ø­Ø§Ù„Ø© ÙƒØ´
                if (this.isKingInCheck(kingPosition.row, kingPosition.col)) {
                    if (!this.hasDefensiveMoves(kingPosition.row, kingPosition.col)) {
                        this.gameOver = true;

                        const whiteButton = document.getElementById('white-button');
                        if (whiteButton) {
                            whiteButton.click();
                        } else {
                            console.error("Ø§Ù„Ø¹Ù†ØµØ± 'white-button' ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.");
                        }

                        document.getElementById('game-over').innerText = `ÙƒØ´ Ù…Ø§Øª! Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ ${this.turn === 'white' ? 'Ø§Ù„Ø£Ø³ÙˆØ¯' : 'Ø§Ù„Ø£Ø¨ÙŠØ¶'}`;
                        document.getElementById('restart-button').style.display = 'block';
                    } else {
                        document.getElementById('game-over').innerText = 'ÙƒØ´! ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ù„Ùƒ Ø£Ùˆ Ø§Ù„Ø¯ÙØ§Ø¹ Ø¹Ù†Ù‡.';
                    }
                } else {
                    document.getElementById('game-over').innerText = '';
                }
            }
               

            hasDefensiveMoves(row, col) {
            const king = this.board[row][col];
            const pieces = this.turn === 'white' ? ["â™™", "â™–", "â™˜", "â™—", "â™•", "â™”"] : ["â™Ÿ", "â™œ", "â™", "â™", "â™›", "â™š"];

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (pieces.includes(this.board[i][j])) {
                        for (let x = 0; x < 8; x++) {
                            for (let y = 0; y < 8; y++) {
                                if (this.isValidMove(i, j, x, y)) {
                                    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù…Ø¹Ø±ÙØ© Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØªØ²ÙŠÙ„ Ø§Ù„ÙƒØ´
                                    const originalPiece = this.board[x][y];
                                    this.board[x][y] = this.board[i][j];
                                    this.board[i][j] = null;

                                    const isStillInCheck = this.isKingInCheck(row, col);

                                    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ
                                    this.board[i][j] = this.board[x][y];
                                    this.board[x][y] = originalPiece;

                                    if (!isStillInCheck) {
                                        return true; // ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ© ØªÙ…Ù†Ø¹ Ø§Ù„ÙƒØ´
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return false; // Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ø¯ÙØ§Ø¹ÙŠØ©
        }


            isCheckmate(row, col) {
                // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ Ù„Ø¯ÙŠÙ‡ Ø£ÙŠ Ø­Ø±ÙƒØ§Øª Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©
                for (let i = row - 1; i <= row + 1; i++) {
                    for (let j = col - 1; j <= col + 1; j++) {
                        if (i >= 0 && i < 8 && j >= 0 && j < 8) {
                            if (this.isValidMove(row, col, i, j)) {
                                // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù…Ø¹Ø±ÙØ© Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØªØ²ÙŠÙ„ Ø§Ù„ÙƒØ´
                                const originalPiece = this.board[i][j];
                                this.board[i][j] = this.board[row][col];
                                this.board[row][col] = null;

                                const isStillInCheck = this.isKingInCheck(i, j);

                                // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ
                                this.board[row][col] = this.board[i][j];
                                this.board[i][j] = originalPiece;

                                if (!isStillInCheck) {
                                    return false; // Ø§Ù„Ù…Ù„Ùƒ Ù„Ø¯ÙŠÙ‡ Ø­Ø±ÙƒØ© ØªØ²ÙŠÙ„ Ø§Ù„ÙƒØ´
                                }
                            }
                        }
                    }
                }

                // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ù„Ø£ÙŠ Ù‚Ø·Ø¹Ø© Ø£Ø®Ø±Ù‰ Ø£Ù† ØªÙ…Ù†Ø¹ Ø§Ù„ÙƒØ´
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = this.board[i][j];
                        if (piece && (this.turn === 'white' ? "â™™â™–â™˜â™—â™•â™”".includes(piece) : "â™Ÿâ™œâ™â™â™›â™š".includes(piece))) {
                            for (let x = 0; x < 8; x++) {
                                for (let y = 0; y < 8; y++) {
                                    if (this.isValidMove(i, j, x, y)) {
                                        // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù…Ø¹Ø±ÙØ© Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØªØ²ÙŠÙ„ Ø§Ù„ÙƒØ´
                                        const originalPiece = this.board[x][y];
                                        this.board[x][y] = this.board[i][j];
                                        this.board[i][j] = null;

                                        const isStillInCheck = this.isKingInCheck(row, col);

                                        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‚Ø·Ø¹ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ
                                        this.board[i][j] = this.board[x][y];
                                        this.board[x][y] = originalPiece;

                                        if (!isStillInCheck) {
                                            return false; // ÙŠÙˆØ¬Ø¯ Ø­Ø±ÙƒØ© ØªÙ…Ù†Ø¹ Ø§Ù„ÙƒØ´
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // 3. Ø¥Ø°Ø§ Ù„Ù… ØªÙˆØ¬Ø¯ Ø£ÙŠ Ø­Ø±ÙƒØ© ØªÙ…Ù†Ø¹ Ø§Ù„ÙƒØ´ØŒ Ø¥Ø°Ù‹Ø§ ÙƒØ´ Ù…Ø§Øª
                return true;
            }

            checkPawnPromotion(row, col) {
                const piece = this.board[row][col];
                if ((piece === 'â™™' && row === 0) || (piece === 'â™Ÿ' && row === 7)) {
                    const isWhite = piece === 'â™™';
                    const pieces = isWhite ? ["â™•", "â™–", "â™—", "â™˜"] : ["â™›", "â™œ", "â™", "â™"];
                    const newPiece = prompt(`Ø§Ø®ØªØ± Ù‚Ø·Ø¹Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¯Ù‚ Ø¥Ù„ÙŠÙ‡Ø§ (${pieces.join(', ')}):`);
                    if (newPiece && pieces.includes(newPiece)) {
                        this.board[row][col] = newPiece;
                        this.renderBoard();
                    } else {
                        alert("Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¯Ù‚ Ø¥Ù„Ù‰ ÙˆØ²ÙŠØ± Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§.");
                        this.board[row][col] = isWhite ? "â™•" : "â™›";
                        this.renderBoard();
                    }
                }
            }

            restartGame() {
                this.board = this.createBoard();
                this.turn = 'white';
                this.gameOver = false;
                this.renderBoard();
                this.updateTurnDisplay();
                document.getElementById('game-over').innerText = '';
                document.getElementById('restart-button').style.display = 'none';
            }
        }

    

/*
        document.addEventListener('DOMContentLoaded', () => {
            document.body.innerHTML += '<div id="turn-display" style="font-size: 20px; margin-top: 10px;"></div>';
            document.body.innerHTML += '<div id="chessboard"></div>';

            setTimeout(() => {
                new ChessGame();
            }, 100);
        });

        */

      // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        document.addEventListener("DOMContentLoaded", () => {
            document.getElementById('white-button').addEventListener('click', () => {
                new ChessGame('white');
            });

            document.getElementById('black-button').addEventListener('click', () => {
                new ChessGame('black');
            });
        });

document.getElementById('white-button').addEventListener('click', () => new ChessGame('white'));
document.getElementById('black-button').addEventListener('click', () => new ChessGame('black'));


    </script>
</body>
</html>


